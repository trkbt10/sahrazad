
kgf 0.5
language: typescript

=== lex
# キーワードと識別子・文字列・数値・記号・空白/コメント
TOKEN KW_import   /\bimport\b/m
TOKEN KW_from     /\bfrom\b/m
TOKEN KW_export   /\bexport\b/m
TOKEN KW_function /\bfunction\b/m
TOKEN KW_type     /\btype\b/m
TOKEN KW_interface/\binterface\b/m
TOKEN KW_let      /\blet\b/m
TOKEN KW_const    /\bconst\b/m
TOKEN KW_var      /\bvar\b/m
TOKEN KW_return   /\breturn\b/m
TOKEN Ident       /[A-Za-z_$][A-Za-z0-9_$]*/m
TOKEN StringLit   /"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'/m
TOKEN NumberLit   /(?:0|[1-9][0-9]*)(?:\.[0-9]+)?/m
TOKEN Punct       /[{}()\[\];,.:<>*+\-=/]/m
SKIP  WS          /(?:\s+|\/\/[^\n]*|\/\*[\s\S]*?\*\/)+/m

=== grammar
# モジュール
Module -> (ImportDecl / ExportStmt / TopDecl / Stmt)*

# import
ImportDecl -> KW_import ( ImportClause )? KW_from StringLit ';' @edge(kind=moduleDependsOn, to=$resolve($StringLit), via=$StringLit, dep_kind='value')
ImportDecl -> KW_import StringLit ';'                         @edge(kind=moduleDependsOn, to=$resolve($StringLit), via=$StringLit, dep_kind='value')

# export * from 'x'; / export { a as b } from 'x';
ExportStmt -> KW_export '*' KW_from StringLit ';'             @edge(kind=moduleDependsOn, to=$resolve($StringLit), via=$StringLit, dep_kind='value') @edge(kind=reexports, to=$resolve($StringLit))
ExportStmt -> KW_export '{' (Ident (KW_as Ident)? (',' Ident (KW_as Ident)? )* )? '}' KW_from StringLit ';' @edge(kind=moduleDependsOn, to=$resolve($StringLit), via=$StringLit, dep_kind='value')

# トップレベル宣言
TopDecl -> VarDecl / FnDecl / TypeAlias

# 変数宣言: let/const/var a: T = f(b), c;
VarDecl -> (KW_let / KW_const / KW_var) VarList ';'
VarList -> VarItem (',' VarItem)*
VarItem -> id:Ident (':' Type)? ('=' Expr)? @def($id, kind='Variable', ns='value')

# 関数宣言
FnDecl -> KW_function id:Ident '(' ParamList? ')' Block @def($id, kind='Function', ns='value')
ParamList -> Param (',' Param)*
Param -> id:Ident (':' Type)? @def($id, kind='Param', ns='value')

# 型エイリアス
TypeAlias -> KW_type id:Ident '=' Type ';' @def($id, kind='TypeAlias', ns='type')

# 文（最小）
Stmt -> KW_return Expr? ';' / Expr ';' / Block

# ブロック（最小）
Block -> '{' (Stmt)* '}'

# 式（最小）：呼び出し＋引数抽出・識別子参照
Expr -> CallExpr / Primary
CallExpr -> callee:Primary args:Args @call($callee, $args)
Args -> '(' ( Arg (',' Arg)* )? ')'
Arg -> argspan:( ArgInner )
ArgInner -> (Primary / NumberLit / StringLit / '(' ArgInner ')' )*

Primary -> id:Ident @ref($id, ns='value') / '(' Expr ')' / NumberLit / StringLit

# 型（最小）：QualifiedName + 簡易ジェネリクス or オブジェクト型 { ... }
Type -> '{' (Punct / Ident / StringLit / NumberLit )* '}' \
     / TypeRef ( '<' (Type (',' Type)*)? '>' )?
TypeRef -> qn:(Ident ('.' Ident)*)  @ref($qn, ns='type')

=== resolver
sources: .ts, .tsx, .d.ts
relative_prefixes: ./, ../, /
exts: .ts, .tsx, .d.ts
indexes: /index.ts, /index.tsx, /index.d.ts
bare_prefix: npm:
module_path_style: slash
aliases:
  -
    pattern: ^@/(.*)$
    replace: src/\1
